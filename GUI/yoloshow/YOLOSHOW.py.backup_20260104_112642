from utils import glo
import json
import os
import shutil
import random
from ui.YOLOSHOWUI import Ui_MainWindow
from PySide6.QtGui import QColor
from PySide6.QtWidgets import QFileDialog, QMainWindow
from yoloshow.YOLOThreadPool import YOLOThreadPool
from PySide6.QtCore import QTimer, Qt
from PySide6 import QtCore, QtGui
from yoloshow.YOLOSHOWBASE import YOLOSHOWBASE, MODEL_THREAD_CLASSES

GLOBAL_WINDOW_STATE = True
WIDTH_LEFT_BOX_STANDARD = 80
WIDTH_LEFT_BOX_EXTENDED = 100
WIDTH_LOGO = 60
UI_FILE_PATH = "ui/YOLOSHOWUI.ui"
KEYS_LEFT_BOX_MENU = ['src_webcam', 'src_folder', 'src_vsmode']  # 已移除 src_camera


# YOLOSHOW窗口类 动态加载UI文件 和 Ui_mainWindow
class YOLOSHOW(QMainWindow, YOLOSHOWBASE):
    def __init__(self):
        super().__init__()
        self.current_model = None
        self.current_workpath = os.getcwd()
        self.inputPath = None
        self.result_statistic = None
        self.detect_result = None

        # --- 加载UI --- #
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        
        self.setAttribute(Qt.WA_TranslucentBackground, True)  # 透明背景
        self.setWindowFlags(Qt.FramelessWindowHint)  # 无头窗口
        self.log("窗口属性设置完成")
        
        self.log("初始化侧边栏")
        self.initSiderWidget()
        self.log("侧边栏初始化完成")
        # --- 加载UI --- #

        # --- 最大化 最小化 关闭 --- #
        self.ui.maximizeButton.clicked.connect(self.maxorRestore)
        self.ui.minimizeButton.clicked.connect(self.showMinimized)
        self.ui.closeButton.clicked.connect(self.close)
        self.ui.topbox.doubleClickFrame.connect(self.maxorRestore)
        # --- 最大化 最小化 关闭 --- #

        # --- 播放 暂停 停止 --- #
        self.playIcon = QtGui.QIcon()
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/play.png"), QtGui.QIcon.Normal,
                                QtGui.QIcon.Off)
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/pause.png"), QtGui.QIcon.Active,
                                QtGui.QIcon.On)
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/pause.png"),
                                QtGui.QIcon.Selected, QtGui.QIcon.On)
        self.ui.run_button.setCheckable(True)
        self.ui.run_button.setIcon(self.playIcon)
        # --- 播放 暂停 停止 --- #

        # --- 自动加载/动态改变 PT 模型 --- #
        self.pt_Path = f"{self.current_workpath}/ptfiles/"
        os.makedirs(self.pt_Path, exist_ok=True)
        self.pt_list = os.listdir(f'{self.current_workpath}/ptfiles/')
        self.pt_list = [file for file in self.pt_list if file.endswith('.pt')]
        self.pt_list.sort(key=lambda x: os.path.getsize(f'{self.current_workpath}/ptfiles/' + x))
        self.ui.model_box.clear()
        self.ui.model_box.addItems(self.pt_list)
        self.qtimer_search = QTimer(self)
        self.qtimer_search.timeout.connect(lambda: self.loadModels())
        self.qtimer_search.start(2000)
        self.ui.model_box.currentTextChanged.connect(self.changeModel)
        self.log("开始加载PT模型列表")
        self.log(f"找到 {len(self.pt_list)} 个模型文件: {self.pt_list}")
        # --- 自动加载/动态改变 PT 模型 --- #

        # --- 导入 图片/视频、调用摄像头、导入文件夹（批量处理）、结果统计图片、结果统计表格 --- #
        self.ui.src_img.clicked.connect(self.selectFile)
        self.ui.src_webcam.clicked.connect(self.selectWebcam)
        self.ui.src_folder.clicked.connect(self.selectFolder)
        # self.ui.src_camera.clicked.connect(self.selectRtsp)  # 网络摄像头功能已禁用
        self.ui.src_result.clicked.connect(self.showResultStatics)
        self.ui.src_table.clicked.connect(self.showTableResult)
        # --- 导入 图片/视频、调用摄像头、导入文件夹（批量处理） --- #

        # --- 导入模型、 导出结果 --- #
        # self.ui.import_button.clicked.connect(self.importModel)
        # self.ui.save_status_button.clicked.connect(self.saveStatus)
        self.ui.save_button.clicked.connect(self.saveResult)
        self.ui.save_button.setEnabled(True)
        # --- 导入模型、 导出结果 --- #

        # --- 视频、图片 预览 --- #
        self.ui.main_leftbox.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        self.ui.main_rightbox.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        # --- 视频、图片 预览 --- #

        # --- 状态栏 初始化 --- #
        # 状态栏阴影效果
        self.shadowStyle(self.ui.mainBody, QColor(0, 0, 0, 38), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Class_QF, QColor(142, 197, 252), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.classesLabel, QColor(142, 197, 252), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Target_QF, QColor(159, 172, 230), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.targetLabel, QColor(159, 172, 230), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Fps_QF, QColor(170, 128, 213), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.fpsLabel, QColor(170, 128, 213), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Model_QF, QColor(162, 129, 247), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.modelLabel, QColor(162, 129, 247), top_bottom=['top', 'bottom'])
        # 状态栏默认显示
        self.model_name = self.ui.model_box.currentText()  # 获取默认 model
        self.ui.Class_num.setText('--')
        self.ui.Target_num.setText('--')
        self.ui.fps_label.setText('--')
        self.ui.Model_label.setText(str(self.model_name).replace(".pt", ""))
        self.log("状态栏初始化完成")
        # --- 状态栏 初始化 --- #

        self.log("开始初始化线程")
        self.initThreads()
        self.log("线程初始化完成")

        # --- 超参数调整 --- #
        self.ui.iou_spinbox.valueChanged.connect(
            lambda x: self.changeValue(x, 'iou_spinbox'))  # iou box
        self.ui.iou_slider.valueChanged.connect(lambda x: self.changeValue(x, 'iou_slider'))  # iou scroll bar
        self.ui.conf_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'conf_spinbox'))  # conf box
        self.ui.conf_slider.valueChanged.connect(lambda x: self.changeValue(x, 'conf_slider'))  # conf scroll bar
        self.ui.speed_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'speed_spinbox'))  # speed box
        self.ui.speed_slider.valueChanged.connect(lambda x: self.changeValue(x, 'speed_slider'))  # speed scroll bar
        self.ui.line_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'line_spinbox'))  # line box
        self.ui.line_slider.valueChanged.connect(lambda x: self.changeValue(x, 'line_slider'))  # line slider
        # --- 超参数调整 --- #

        # --- 开始 / 停止 --- #
        self.ui.run_button.clicked.connect(self.runorContinue)
        self.ui.stop_button.clicked.connect(self.stopDetect)
        # --- 开始 / 停止 --- #

        # --- Setting栏 初始化 --- #
        self.loadConfig()
        # --- Setting栏 初始化 --- #

        # --- MessageBar Init --- #
        self.showStatus("欢迎使用坐姿检测系统 (Welcome to SPD)")
        # --- MessageBar Init --- #
        
        # --- 修复界面文字显示 --- #
        self.fixChineseLabels()
        # --- 修复界面文字显示 --- #
        
        # --- 初始化结果文件，清空旧数据 --- #
        result_json_path = f'{self.current_workpath}/config/result.json'
        result_png_path = f'{self.current_workpath}/config/result.png'
        # 清空result.json
        with open(result_json_path, 'w', encoding='utf-8') as f:
            json.dump({}, f, ensure_ascii=False, indent=4)
        # 删除旧的result.png（如果存在）
        if os.path.exists(result_png_path):
            try:
                os.remove(result_png_path)
            except:
                pass
        # --- 初始化结果文件，清空旧数据 --- #

        # mediapipe
        self.mpIcon = QtGui.QIcon()
        self.mpIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/check_no.png"), QtGui.QIcon.Normal,
                                QtGui.QIcon.Off)
        self.mpIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/check_yes.png"), QtGui.QIcon.Active,
                                QtGui.QIcon.On)
        self.mpIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/check_yes.png"),
                                QtGui.QIcon.Selected, QtGui.QIcon.On)
        self.ui.mp_button.setCheckable(True)
        self.ui.mp_button.setIcon(self.mpIcon)
        self.ui.mp_button.clicked.connect(self.use_mp)
        
        self.log("========== 单模式初始化完成 ==========")

    def log(self, message):
        """写入日志到文件和控制台"""
        import datetime
        timestamp = datetime.datetime.now().strftime('%H:%M:%S.%f')[:-3]
        log_message = f"[{timestamp}] {message}"
        print(log_message)
        if hasattr(self, 'log_file') and self.log_file:
            try:
                self.log_file.write(log_message + '\n')
                self.log_file.flush()
            except:
                pass

    def initThreads(self):
        self.log("[DEBUG] ========== 单模式 initThreads 开始 ==========")
        self.yolo_threads = YOLOThreadPool()
        self.log("[DEBUG] YOLOThreadPool 创建成功")
        
        # 获取当前Model
        model_name = self.checkCurrentModel()
        self.log(f"[DEBUG] 当前模型: {model_name}")
        
        if model_name:
            self.log(f"[DEBUG] 开始创建线程: {model_name}")
            self.yolo_threads.set(model_name, MODEL_THREAD_CLASSES[model_name]())
            self.log(f"[DEBUG] 线程创建成功")
            
            self.log(f"[DEBUG] 开始初始化模型: {model_name}")
            self.initModel(yoloname=model_name)
            self.log(f"[DEBUG] 模型初始化完成")
        else:
            self.log("[WARNING] 未找到有效的模型")
        
        self.log("[DEBUG] ========== 单模式 initThreads 完成 ==========")

    def initModel(self, yoloname=None):
        """重写initModel方法以添加日志记录"""
        self.log(f"[DEBUG] ========== initModel 开始: {yoloname} ==========")
        
        thread = self.yolo_threads.get(yoloname)
        self.log(f"[DEBUG] 获取到线程: {thread}")
        
        if not thread:
            self.log(f"[ERROR] 未找到线程: {yoloname}")
            raise ValueError(f"No thread found for '{yoloname}'")
        
        self.log(f"[DEBUG] 配置模型")
        thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box.currentText()
        self.log(f"[DEBUG] 模型路径: {thread.new_model_name}")
        
        thread.progress_value = self.ui.progress_bar.maximum()

        # 信号槽连接
        self.log(f"[DEBUG] 连接信号槽")
        thread.send_input.connect(lambda x: self.showImg(x, self.ui.main_leftbox, 'img'))
        thread.send_output.connect(lambda x: self.showImg(x, self.ui.main_rightbox, 'img'))
        thread.send_msg.connect(lambda x: self.showStatus(x))
        thread.send_progress.connect(lambda x: self.ui.progress_bar.setValue(x))
        thread.send_fps.connect(lambda x: self.ui.fps_label.setText(str(x)))
        thread.send_class_num.connect(lambda x: self.ui.Class_num.setText(str(x)))
        thread.send_target_num.connect(lambda x: self.ui.Target_num.setText(str(x)))
        thread.send_result_picture.connect(lambda x: self.setResultStatistic(x))
        thread.send_result_table.connect(lambda x: self.setTableResult(x))
        self.log(f"[DEBUG] 信号槽连接完成")
        
        self.log(f"[DEBUG] ========== initModel 完成: {yoloname} ==========")

    # 导出结果
    def saveResult(self):
        # 判断是否是摄像头模式（inputPath 是整数）
        is_webcam = isinstance(self.inputPath, int)
        
        # 检查是否有线程正在运行且未暂停
        is_detecting = False
        for thread in self.yolo_threads.threads_pool.values():
            if thread.isRunning() and hasattr(thread, 'is_continue') and thread.is_continue:
                is_detecting = True
                break
        
        if is_detecting:
            if is_webcam:
                # 摄像头模式：提示先暂停
                self.showStatus("请先暂停检测再保存结果 (Please pause detection before saving)")
            else:
                # 文件/视频模式：提示等待检测完成
                self.showStatus("检测正在进行中，请等待检测完成 (Detection in progress, please wait)")
            return
        
        # 检查是否有检测结果（优先检查result.json，因为摄像头模式可能没有设置res_status）
        result_json_path = os.path.join(self.current_workpath, 'config', 'result.json')
        has_result_data = False
        
        if os.path.exists(result_json_path):
            with open(result_json_path, 'r', encoding='utf-8') as f:
                result_data = json.load(f)
            if result_data:
                has_result_data = True
        
        # 如果没有结果数据，再检查是否开始过检测
        if not has_result_data:
            # 检查是否已经开始过检测
            if not any(thread.res_status for thread in self.yolo_threads.threads_pool.values()):
                self.showStatus("请先选择图片/视频再开始检测 (Please select the Image/Video before starting detection)")
            else:
                self.showStatus("无检测结果，无法保存 (No detection results to save)")
            return
        
        config_file = f'{self.current_workpath}/config/save.json'
        with open(config_file, 'r', encoding='utf-8') as f:
            config = json.load(f)

        save_path = config.get('save_path', os.getcwd())
        
        # 单模式：统一选择文件夹保存结果图、结果表txt、结果表json
        self.OutputDir = QFileDialog.getExistingDirectory(
            self,
            "选择保存结果的文件夹 (Select Folder to Save Results)",
            save_path,
        )
        
        if not self.OutputDir:
            return
        
        # 保存结果图和结果表
        self.saveResultStatistics(self.OutputDir)
        
        self.showStatus(f'保存成功，位置：{self.OutputDir} (Saved Successfully)')

        config['save_path'] = self.OutputDir
        config_json = json.dumps(config, ensure_ascii=False, indent=2)
        with open(config_file, 'w', encoding='utf-8') as f:
            f.write(config_json)
    
    def saveResultStatistics(self, output_dir):
        """保存结果图和结果表到指定目录
        
        Args:
            output_dir: 输出目录
        """
        try:
            # 读取结果统计数据
            result_json_path = os.path.join(self.current_workpath, 'config', 'result.json')
            result_png_path = os.path.join(self.current_workpath, 'config', 'result.png')
            
            # 检查文件是否存在
            if not os.path.exists(result_json_path):
                self.log(f"[WARNING] 结果文件不存在: {result_json_path}")
                return
            
            # 读取结果数据
            with open(result_json_path, 'r', encoding='utf-8') as f:
                result_data = json.load(f)
            
            if not result_data:
                self.log(f"[WARNING] 结果数据为空")
                return
            
            # 保存 JSON 文件
            output_json_path = os.path.join(output_dir, "result.json")
            with open(output_json_path, 'w', encoding='utf-8') as f:
                json.dump(result_data, f, ensure_ascii=False, indent=4)
            self.log(f"[INFO] 结果JSON已保存: {output_json_path}")
            
            # 保存 PNG 文件（如果存在）
            if os.path.exists(result_png_path):
                output_png_path = os.path.join(output_dir, "result.png")
                shutil.copy(result_png_path, output_png_path)
                self.log(f"[INFO] 结果图已保存: {output_png_path}")
            
            # 保存 TXT 文件（结果表格式）
            output_txt_path = os.path.join(output_dir, "result.txt")
            with open(output_txt_path, 'w', encoding='utf-8') as f:
                f.write("检测结果统计 (Detection Result Statistics)\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"{'类别 (Class)':<30} {'数量 (Count)':>10}\n")
                f.write("-" * 50 + "\n")
                for class_name, count in result_data.items():
                    f.write(f"{class_name:<30} {count:>10}\n")
                f.write("-" * 50 + "\n")
                f.write(f"{'总计 (Total)':<30} {sum(result_data.values()):>10}\n")
            self.log(f"[INFO] 结果表已保存: {output_txt_path}")
            
        except Exception as e:
            self.log(f"[ERROR] 保存结果统计时出错: {e}")
            import traceback
            traceback.print_exc()
    
    # 加载 pt 模型到 model_box
    def loadModels(self):
        pt_list = os.listdir(f'{self.current_workpath}/ptfiles/')
        pt_list = [file for file in pt_list if file.endswith('.pt')]
        pt_list.sort(key=lambda x: os.path.getsize(f'{self.current_workpath}/ptfiles/' + x))

        if pt_list != self.pt_list:
            self.pt_list = pt_list
            self.ui.model_box.clear()
            self.ui.model_box.addItems(self.pt_list)

    def stopOtherModelProcess(self, model_name, current_yoloname):
        yolo_thread = self.yolo_threads.get(model_name)
        yolo_thread.finished.connect(lambda: self.resignModel(current_yoloname))
        yolo_thread.stop_dtc = True
        self.yolo_threads.stop_thread(model_name)

    # 停止其他模型
    def stopOtherModel(self, current_yoloname=None):
        for model_name in self.yolo_threads.threads_pool.keys():
            if not current_yoloname or model_name == current_yoloname:
                continue
            if self.yolo_threads.get(model_name).isRunning():
                self.stopOtherModelProcess(model_name, current_yoloname)

    # 重新加载模型
    def resignModel(self, model_name):
        self.log(f"[DEBUG] ========== resignModel 开始: {model_name} ==========")
        
        # 重载 common 和 yolo 模块
        glo.set_value('yoloname', model_name)
        self.log(f"[DEBUG] 设置全局变量 yoloname: {model_name}")
        
        # 注释掉 reloadModel()，因为它会导致线程对象引用的类定义失效
        # 在单模式下，线程已经在 initThreads() 中创建，不需要重新加载模块
        # self.reloadModel()
        
        self.log(f"[DEBUG] 创建新线程")
        self.yolo_threads.set(model_name, MODEL_THREAD_CLASSES[model_name]())
        self.log(f"[DEBUG] 新线程创建成功")
        
        self.log(f"[DEBUG] 初始化模型")
        self.initModel(yoloname=model_name)
        self.log(f"[DEBUG] 模型初始化完成")
        
        self.log(f"[DEBUG] 运行模型")
        self.runModel(True)
        self.log(f"[DEBUG] ========== resignModel 完成: {model_name} ==========")

    # Model 变化
    def changeModel(self):
        try:
            self.log(f"[DEBUG] ========== changeModel 开始 ==========")
            
            self.model_name = self.ui.model_box.currentText()
            self.log(f"[DEBUG] 选择的模型: {self.model_name}")
            
            self.ui.Model_label.setText(str(self.model_name).replace(".pt", ""))  # 修改状态栏显示
            self.log(f"[DEBUG] 状态栏已更新")
            
            model_name = self.checkCurrentModel()
            self.log(f"[DEBUG] 检查当前模型: {model_name}")
            
            if not model_name:
                self.log(f"[WARNING] 未找到有效的模型")
                return
            
            # 停止其他模型
            self.log(f"[DEBUG] 停止其他模型")
            self.stopOtherModel(model_name)
            self.log(f"[DEBUG] 其他模型已停止")
            
            yolo_thread = self.yolo_threads.get(model_name)
            self.log(f"[DEBUG] 获取线程: {yolo_thread}")
            
            if yolo_thread is not None:
                self.log(f"[DEBUG] 线程已存在，更新模型路径")
                yolo_thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box.currentText()
                self.log(f"[DEBUG] 新模型路径: {yolo_thread.new_model_name}")
                self.log(f"[DEBUG] 加载配置")
                self.loadConfig()
                self.log(f"[DEBUG] 配置加载完成")
                self.showStatus(f"模型切换成功：{model_name} (Change Model to {model_name} Successfully)")
                self.log(f"[DEBUG] 状态消息已显示")
            else:
                self.log(f"[DEBUG] 线程不存在，创建新线程")
                self.yolo_threads.set(model_name, MODEL_THREAD_CLASSES[model_name]())
                self.log(f"[DEBUG] 新线程已创建")
                self.log(f"[DEBUG] 初始化模型")
                self.initModel(yoloname=model_name)
                self.log(f"[DEBUG] 模型初始化完成")
                self.log(f"[DEBUG] 加载配置")
                self.loadConfig()
                self.log(f"[DEBUG] 配置加载完成")
                self.showStatus(f"模型切换成功：{model_name} (Change Model to {model_name} Successfully)")
                self.log(f"[DEBUG] 状态消息已显示")
            
            self.log(f"[DEBUG] ========== changeModel 完成 ==========")
        except Exception as e:
            self.log(f"[ERROR] changeModel 发生异常: {e}")
            import traceback
            self.log(f"[ERROR] 异常堆栈:\n{traceback.format_exc()}")
            raise
    
    def loadConfig(self):
        """重写loadConfig方法以添加日志"""
        try:
            self.log(f"[DEBUG] ========== loadConfig 开始 ==========")
            
            # 1、随机初始化超参数，防止切换模型时，超参数不变
            self.log(f"[DEBUG] 生成随机参数")
            params = {"iou": round(random.uniform(0, 1), 2),
                      "conf": round(random.uniform(0, 1), 2),
                      "delay": random.randint(10, 50),
                      "line_thickness": random.randint(1, 5)}
            self.log(f"[DEBUG] 随机参数: {params}")
            
            self.log(f"[DEBUG] 更新参数（第一次）")
            self.updateParams(params)
            self.log(f"[DEBUG] 参数更新完成（第一次）")
            
            # 2、绑定配置项超参数
            self.log(f"[DEBUG] 加载配置文件")
            params = {"iou": 0.45, "conf": 0.25, "delay": 10, "line_thickness": 3}
            params = self.loadAndSetParams('config/setting.json', params)
            self.log(f"[DEBUG] 配置文件参数: {params}")
            
            self.log(f"[DEBUG] 更新参数（第二次）")
            self.updateParams(params)
            self.log(f"[DEBUG] 参数更新完成（第二次）")
            
            self.log(f"[DEBUG] ========== loadConfig 完成 ==========")
        except Exception as e:
            self.log(f"[ERROR] loadConfig 发生异常: {e}")
            import traceback
            self.log(f"[ERROR] 异常堆栈:\n{traceback.format_exc()}")
            raise

    def runModelProcess(self, yolo_name):
        yolo_thread = self.yolo_threads.get(yolo_name)
        yolo_thread.source = self.inputPath
        yolo_thread.stop_dtc = False
        if self.ui.run_button.isChecked():
            yolo_thread.is_continue = True
            self.yolo_threads.start_thread(yolo_name)
        else:
            yolo_thread.is_continue = False
            
            # === 停止检测时发送累积的结果 ===
            print(f"[停止检测] 准备发送结果数据")
            print(f"[停止检测] webcam={yolo_thread.webcam if hasattr(yolo_thread, 'webcam') else 'N/A'}")
            print(f"[停止检测] all_labels_dict={getattr(yolo_thread, 'all_labels_dict', {})}")
            
            # 摄像头模式：使用累积的结果
            if hasattr(yolo_thread, 'webcam') and yolo_thread.webcam:
                if hasattr(yolo_thread, 'all_labels_dict') and yolo_thread.all_labels_dict:
                    yolo_thread.results_picture = yolo_thread.all_labels_dict.copy()
                    print(f"[停止检测] 使用累积结果: {yolo_thread.results_picture}")
            
            # 发送结果图片
            if hasattr(yolo_thread, 'results_picture') and yolo_thread.results_picture:
                yolo_thread.send_result_picture.emit(yolo_thread.results_picture)
                print(f"[停止检测] 已发送结果图片")
            
            # 发送结果表格
            results_table = []
            if hasattr(yolo_thread, 'results_picture'):
                for key, value in yolo_thread.results_picture.items():
                    results_table.append([key, str(value)])
            
            if results_table:
                yolo_thread.send_result_table.emit(results_table)
                print(f"[停止检测] 已发送结果表格: {results_table}")
            else:
                print(f"[停止检测] 结果表格为空")
            
            self.showStatus('暂停检测 (Pause Detection)')

    def runModel(self, runbuttonStatus=None):
        # self.ui.save_status_button.setEnabled(False)
        if runbuttonStatus:
            self.ui.run_button.setChecked(True)
        current_model_name = self.checkCurrentModel()
        if current_model_name is not None:
            self.runModelProcess(current_model_name)
        else:
            self.showStatus('当前模型不支持 (The current model is not supported)')
            if self.ui.run_button.isChecked():
                self.ui.run_button.setChecked(False)

    # 开始/暂停 预测
    def runorContinue(self):
        if self.inputPath is not None:
            # 清空之前的检测结果，避免结果累加
            result_json_path = os.path.join(self.current_workpath, 'config', 'result.json')
            try:
                if os.path.exists(result_json_path):
                    with open(result_json_path, 'w', encoding='utf-8') as f:
                        json.dump({}, f, ensure_ascii=False, indent=4)
                    print("[DEBUG] 已清空之前的检测结果 result.json")
            except Exception as e:
                print(f"[WARNING] 清空结果文件失败: {e}")
            
            self.changeModel()
            self.runModel()
        else:
            self.showStatus("请先选择图片/视频再开始检测 (Please select the Image/Video before starting detection)")
            self.ui.run_button.setChecked(False)

    # 停止识别
    def stopDetect(self):
        self.quitRunningModel(stop_status=True)
        self.ui.run_button.setChecked(False)
        self.ui.progress_bar.setValue(0)
        self.ui.main_leftbox.clear()  # clear image display
        self.ui.main_rightbox.clear()
        self.ui.Class_num.setText('--')
        self.ui.Target_num.setText('--')
        self.ui.fps_label.setText('--')

    def fixChineseLabels(self):
        """修复界面文字显示，避免截断并添加状态栏中文标注"""
        # 左侧菜单按钮 - 使用换行符避免文字被截断
        self.ui.src_img.setText("Media\n媒体")
        self.ui.src_webcam.setText("Webcam\n摄像头")
        self.ui.src_folder.setText("Folder\n文件夹")
        self.ui.src_result.setText("Result Pic\n结果图片")
        self.ui.src_table.setText("Result Tab\n结果表格")
        self.ui.src_vsmode.setText("VS Mode\n对比模式")
        
        # 状态栏标签 - 使用简洁的中文标注（避免换行导致遮挡）
        self.ui.label_5.setText("类别")
        self.ui.label_6.setText("目标")
        self.ui.label_7.setText("帧率")
        self.ui.label_8.setText("模型")
        
        # 添加工具提示（鼠标悬停显示完整说明）
        self.ui.label_5.setToolTip("Classes 类别\n检测到的类别数量\nNumber of detected classes")
        self.ui.label_6.setToolTip("Targets 目标\n检测到的目标数量\nNumber of detected targets")
        self.ui.label_7.setToolTip("Fps 帧率\n每秒处理帧数\nFrames per second")
        self.ui.label_8.setToolTip("Model 模型\n当前使用的模型\nCurrent model in use")
        
        self.log("[DEBUG] 单模式界面文字已修复 / Single mode interface text fixed")

    def closeEvent(self, event):
        """窗口关闭时清理资源"""
        self.log("[INFO] 单模式窗口关闭，清理资源")
        
        # 关闭日志文件
        if hasattr(self, 'log_file') and self.log_file:
            try:
                self.log_file.close()
            except:
                pass
        
        # 调用父类的closeEvent
        super().closeEvent(event)
