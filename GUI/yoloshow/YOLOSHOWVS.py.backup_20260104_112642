from utils import glo
import json
import os
import cv2
import numpy as np
import time
from PySide6.QtGui import QColor
from PySide6.QtWidgets import QFileDialog, QMainWindow
from PySide6.QtCore import QTimer, Qt
from PySide6 import QtCore, QtGui
from ui.YOLOSHOWUIVS import Ui_MainWindow
from yoloshow.YOLOSHOWBASE import YOLOSHOWBASE, MODEL_THREAD_CLASSES
from yoloshow.YOLOThreadPool import YOLOThreadPool

GLOBAL_WINDOW_STATE = True
WIDTH_LEFT_BOX_STANDARD = 80
WIDTH_LEFT_BOX_EXTENDED = 200
WIDTH_LOGO = 60
UI_FILE_PATH = "ui/YOLOSHOWUIVS.ui"


# YOLOSHOW窗口类 动态加载UI文件 和 Ui_mainWindow
class YOLOSHOWVS(QMainWindow, YOLOSHOWBASE):
    def __init__(self):
        super().__init__()
        
        # 创建日志文件
        import datetime
        log_file = f"debug_vs_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        self.log_file = open(log_file, 'w', encoding='utf-8')
        self.log(f"========== 对比模式初始化开始 ==========")
        self.log(f"日志文件: {log_file}")
        
        self.current_workpath = os.getcwd()
        self.log(f"工作目录: {self.current_workpath}")
        
        self.inputPath = None
        self.result_statistic = None
        self.detect_result = None
        self.log("基本变量初始化完成")

        # --- 加载UI --- #
        self.log("开始加载UI")
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.log("UI加载完成")
        
        self.setAttribute(Qt.WA_TranslucentBackground, True)  # 透明背景
        self.setWindowFlags(Qt.FramelessWindowHint)  # 无头窗口
        self.log("窗口属性设置完成")
        
        # 初始化侧边栏
        self.log("初始化侧边栏")
        self.initSiderWidget()
        self.log("侧边栏初始化完成")

        # --- 最大化 最小化 关闭 --- #
        self.ui.maximizeButton.clicked.connect(self.maxorRestore)
        self.ui.minimizeButton.clicked.connect(self.showMinimized)
        self.ui.closeButton.clicked.connect(self.close)
        self.ui.topbox.doubleClickFrame.connect(self.maxorRestore)
        # --- 最大化 最小化 关闭 --- #

        # --- 播放 暂停 停止 --- #
        self.playIcon = QtGui.QIcon()
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/play.png"), QtGui.QIcon.Normal,
                                QtGui.QIcon.Off)
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/pause.png"), QtGui.QIcon.Active,
                                QtGui.QIcon.On)
        self.playIcon.addPixmap(QtGui.QPixmap(f"{self.current_workpath}/images/newsize/pause.png"),
                                QtGui.QIcon.Selected, QtGui.QIcon.On)
        self.ui.run_button.setCheckable(True)
        self.ui.run_button.setIcon(self.playIcon)
        # --- 播放 暂停 停止 --- #

        # --- 侧边栏缩放 --- #
        self.ui.src_menu.clicked.connect(self.scaleMenu)  # hide menu button
        self.ui.src_setting.clicked.connect(self.scalSetting)  # setting button
        # --- 侧边栏缩放 --- #

        # --- 自动加载/动态改变 PT 模型 --- #
        self.log("开始加载PT模型列表")
        self.pt_Path = f"{self.current_workpath}/ptfiles/"
        os.makedirs(self.pt_Path, exist_ok=True)
        self.pt_list = os.listdir(f'{self.current_workpath}/ptfiles/')
        self.pt_list = [file for file in self.pt_list if file.endswith('.pt')]
        self.pt_list.sort(key=lambda x: os.path.getsize(f'{self.current_workpath}/ptfiles/' + x))
        self.log(f"找到 {len(self.pt_list)} 个模型文件: {self.pt_list}")
        
        # 使用标志文件来标记模型是否已经被 solveYoloConflict 处理过
        # 这样只在第一次运行时处理，避免重复处理导致闪退
        models_solved_flag = f"{self.current_workpath}/ptfiles/.models_solved"
        if not os.path.exists(models_solved_flag):
            try:
                self.log("[INFO] 首次运行，正在处理模型文件...")
                self.solveYoloConflict([f"{self.current_workpath}/ptfiles/" + pt_file for pt_file in self.pt_list])
                # 创建标志文件
                with open(models_solved_flag, 'w') as f:
                    f.write("Models have been processed by solveYoloConflict")
                self.log("[INFO] 模型文件处理完成")
            except Exception as e:
                self.log(f"[ERROR] 处理模型文件时出错: {e}")
                import traceback
                self.log(traceback.format_exc())
        else:
            self.log("[INFO] 模型文件已处理过，跳过 solveYoloConflict")
        
        self.ui.model_box1.clear()
        self.ui.model_box1.addItems(self.pt_list)
        self.ui.model_box2.clear()
        self.ui.model_box2.addItems(self.pt_list)
        self.qtimer_search = QTimer(self)
        self.qtimer_search.timeout.connect(lambda: self.loadModels())
        self.qtimer_search.start(2000)
        self.ui.model_box1.currentTextChanged.connect(lambda: self.changeModel("left"))
        self.ui.model_box2.currentTextChanged.connect(lambda: self.changeModel("right"))
        # --- 自动加载/动态改变 PT 模型 --- #

        # --- 超参数调整 --- #
        self.ui.iou_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'iou_spinbox'))  # iou box
        self.ui.iou_slider.valueChanged.connect(lambda x: self.changeValue(x, 'iou_slider'))  # iou scroll bar
        self.ui.conf_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'conf_spinbox'))  # conf box
        self.ui.conf_slider.valueChanged.connect(lambda x: self.changeValue(x, 'conf_slider'))  # conf scroll bar
        self.ui.speed_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'speed_spinbox'))  # speed box
        self.ui.speed_slider.valueChanged.connect(lambda x: self.changeValue(x, 'speed_slider'))  # speed scroll bar
        self.ui.line_spinbox.valueChanged.connect(lambda x: self.changeValue(x, 'line_spinbox'))  # line box
        self.ui.line_slider.valueChanged.connect(lambda x: self.changeValue(x, 'line_slider'))  # line slider
        # --- 超参数调整 --- #

        # --- 导入 图片/视频、调用摄像头、导入文件夹（批量处理）、结果统计图片、结果统计表格 --- #
        self.ui.src_img.clicked.connect(self.selectFile)
        # 对比模型模式 不支持同时读取摄像头流
        # self.src_webcam.clicked.connect(self.selectWebcam)
        self.ui.src_folder.clicked.connect(self.selectFolder)
        # self.ui.src_camera.clicked.connect(self.selectRtsp)  # 网络摄像头功能已禁用
        # self.ui.src_result.clicked.connect(self.showResultStatics)
        # self.ui.src_table.clicked.connect(self.showTableResult)
        # --- 导入 图片/视频、调用摄像头、导入文件夹（批量处理） --- #

        # --- 导入模型、 导出结果 --- #
        self.ui.save_button.clicked.connect(self.saveResult)
        self.ui.save_button.setEnabled(True)  # 启用保存按钮
        # --- 导入模型、 导出结果 --- #

        # --- 视频、图片 预览 --- #
        self.ui.main_leftbox.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        self.ui.main_rightbox.setAlignment(QtCore.Qt.AlignCenter | QtCore.Qt.AlignVCenter)
        # --- 视频、图片 预览 --- #

        # --- 状态栏 初始化 --- #
        # 状态栏阴影效果
        self.shadowStyle(self.ui.mainBody, QColor(0, 0, 0, 38), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Class_QF1, QColor(142, 197, 252), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Target_QF1, QColor(159, 172, 230), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Fps_QF1, QColor(170, 128, 213), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Model_QF1, QColor(162, 129, 247), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Class_QF2, QColor(142, 197, 252), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Target_QF2, QColor(159, 172, 230), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Fps_QF2, QColor(170, 128, 213), top_bottom=['top', 'bottom'])
        self.shadowStyle(self.ui.Model_QF2, QColor(162, 129, 247), top_bottom=['top', 'bottom'])

        # 状态栏默认显示
        self.model_name1 = self.ui.model_box1.currentText()  # 获取默认 model
        self.ui.Class_num1.setText('--')
        self.ui.Target_num1.setText('--')
        self.ui.fps_label1.setText('--')
        self.ui.Model_label1.setText(str(self.model_name1).replace(".pt", ""))
        self.model_name2 = self.ui.model_box2.currentText()  # 获取默认 model
        self.ui.Class_num2.setText('--')
        self.ui.Target_num2.setText('--')
        self.ui.fps_label2.setText('--')
        self.ui.Model_label2.setText(str(self.model_name2).replace(".pt", ""))
        # --- 状态栏 初始化 --- #

        self.initThreads()

        self.ui.run_button.clicked.connect(self.runorContinue)
        self.ui.stop_button.clicked.connect(self.stopDetect)
        # --- 开始 / 停止 --- #

        # --- Setting栏 初始化 --- #
        self.loadConfig()
        # --- Setting栏 初始化 --- #

        # --- MessageBar Init --- #
        self.showStatus("Welcome to YOLOSHOW")
        # --- MessageBar Init --- #
        
        # --- 添加中文标签到按钮和控件 --- #
        self.addChineseLabels()
        # --- 添加中文标签到按钮和控件 --- #
        
        # --- 初始化结果文件，清空旧数据 --- #
        result_json_path = f'{self.current_workpath}/config/result.json'
        result_png_path = f'{self.current_workpath}/config/result.png'
        # 清空result.json
        with open(result_json_path, 'w', encoding='utf-8') as f:
            json.dump({}, f, ensure_ascii=False, indent=4)
        # 删除旧的result.png（如果存在）
        if os.path.exists(result_png_path):
            try:
                os.remove(result_png_path)
            except:
                pass
        # --- 初始化结果文件，清空旧数据 --- #

    # 日志方法
    def log(self, message):
        """写入日志到文件和控制台"""
        import datetime
        timestamp = datetime.datetime.now().strftime('%H:%M:%S.%f')[:-3]
        log_message = f"[{timestamp}] {message}"
        print(log_message)
        if hasattr(self, 'log_file') and self.log_file:
            try:
                self.log_file.write(log_message + '\n')
                self.log_file.flush()
            except:
                pass
    
    # 初始化左侧菜单栏（重写父类方法，使用对比模式的宽度常量）
    def initSiderWidget(self):
        """初始化侧边栏，使用对比模式特定的宽度设置"""
        from PySide6.QtWidgets import QFrame, QPushButton
        
        # 设置左侧菜单栏初始宽度（使用对比模式的常量）
        self.ui.leftBox.setMinimumWidth(WIDTH_LEFT_BOX_STANDARD)
        self.ui.leftBox.setMaximumWidth(WIDTH_LEFT_BOX_EXTENDED)
        self.ui.leftBox.setFixedWidth(WIDTH_LEFT_BOX_STANDARD)
        
        # logo
        self.ui.logo.setFixedSize(WIDTH_LOGO, WIDTH_LOGO)

        # 将左侧菜单栏的按钮固定宽度
        for child_left_box_widget in self.ui.leftbox_bottom.children():
            if isinstance(child_left_box_widget, QFrame):
                child_left_box_widget.setFixedWidth(WIDTH_LEFT_BOX_EXTENDED)

                for child_left_box_widget_btn in child_left_box_widget.children():
                    if isinstance(child_left_box_widget_btn, QPushButton):
                        child_left_box_widget_btn.setFixedWidth(WIDTH_LEFT_BOX_EXTENDED)
    
    # 侧边栏缩放（重写父类方法，使用对比模式的宽度常量）
    def scaleMenu(self):
        """侧边栏缩放动画，使用对比模式特定的宽度设置"""
        from PySide6.QtCore import QPropertyAnimation, QEasingCurve
        
        leftBoxStart = self.ui.leftBox.width()
        _IS_EXTENDED = leftBoxStart == WIDTH_LEFT_BOX_EXTENDED

        if _IS_EXTENDED:
            leftBoxEnd = WIDTH_LEFT_BOX_STANDARD
            self.log(f"[DEBUG] 收起侧边栏: {leftBoxStart} -> {leftBoxEnd}")
        else:
            leftBoxEnd = WIDTH_LEFT_BOX_EXTENDED
            self.log(f"[DEBUG] 展开侧边栏: {leftBoxStart} -> {leftBoxEnd}")

        # animation
        self.animation = QPropertyAnimation(self.ui.leftBox, b"minimumWidth")
        self.animation.setDuration(500)  # ms
        self.animation.setStartValue(leftBoxStart)
        self.animation.setEndValue(leftBoxEnd)
        self.animation.setEasingCurve(QEasingCurve.InOutQuint)
        self.animation.start()
    
    # 初始化模型线程
    def initThreads(self):
        self.log("[DEBUG] ========== initThreads 开始 ==========")
        try:
            self.yolo_threads = YOLOThreadPool()
            self.log("[DEBUG] YOLOThreadPool 创建成功")
            
            # 获取当前Model
            model_name_left = self.checkCurrentModel(mode="left")
            model_name_right = self.checkCurrentModel(mode="right")
            self.log(f"[DEBUG] 左侧模型: {model_name_left}, 右侧模型: {model_name_right}")
            
            if model_name_left:
                self.log(f"[DEBUG] 开始初始化左侧模型: {model_name_left}")
                self.yolo_threads.set(model_name_left, MODEL_THREAD_CLASSES[model_name_left]())
                self.log(f"[DEBUG] 左侧模型线程创建成功")
                self.initModel(yoloname=model_name_left)
                self.log(f"[DEBUG] 左侧模型初始化完成")
                
            if model_name_right:
                self.log(f"[DEBUG] 开始初始化右侧模型: {model_name_right}")
                self.yolo_threads.set(model_name_right, MODEL_THREAD_CLASSES[model_name_right]())
                self.log(f"[DEBUG] 右侧模型线程创建成功")
                self.initModel(yoloname=model_name_right)
                self.log(f"[DEBUG] 右侧模型初始化完成")
            
            # 默认启用保存模式
            self.log("[DEBUG] 启用默认保存模式")
            for yolo_thread in self.yolo_threads.threads_pool.values():
                yolo_thread.save_res = True
            self.log("[DEBUG] 默认保存模式已启用")
                
            self.log("[DEBUG] ========== initThreads 完成 ==========")
        except Exception as e:
            self.log(f"[ERROR] initThreads 出错: {e}")
            import traceback
            self.log(traceback.format_exc())
            raise

    # 加载模型
    def initModel(self, yoloname=None):
        self.log(f"[DEBUG] ========== initModel 开始: {yoloname} ==========")
        try:
            yolo_thread = self.yolo_threads.get(yoloname)
            if not yolo_thread:
                raise ValueError(f"No thread found for '{yoloname}'")
            
            self.log(f"[DEBUG] 获取到线程: {yolo_thread}")
            
            if yoloname.endswith("left"):
                self.log("[DEBUG] 配置左侧模型")
                # 左侧模型加载
                yolo_thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box1.currentText()
                self.log(f"[DEBUG] 模型路径: {yolo_thread.new_model_name}")
                
                yolo_thread.progress_value = self.ui.progress_bar.maximum()
                yolo_thread.send_output.connect(lambda x: self.showImg(x, self.ui.main_leftbox, 'img'))
                # 第一个模型来控制消息
                yolo_thread.send_msg.connect(lambda x: self.showStatus(x))
                yolo_thread.send_fps.connect(lambda x: self.ui.fps_label1.setText(str(x)))
                yolo_thread.send_class_num.connect(lambda x: self.ui.Class_num1.setText(str(x)))
                yolo_thread.send_target_num.connect(lambda x: self.ui.Target_num1.setText(str(x)))
                self.log("[DEBUG] 左侧模型信号连接完成")
                
            elif yoloname.endswith("right"):
                self.log("[DEBUG] 配置右侧模型")
                # 右侧模型加载
                yolo_thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box2.currentText()
                self.log(f"[DEBUG] 模型路径: {yolo_thread.new_model_name}")
                
                yolo_thread.progress_value = self.ui.progress_bar.maximum()
                yolo_thread.send_output.connect(lambda x: self.showImg(x, self.ui.main_rightbox, 'img'))
                # 后一个模型来控制进度条
                yolo_thread.send_progress.connect(lambda x: self.ui.progress_bar.setValue(x))
                yolo_thread.send_fps.connect(lambda x: self.ui.fps_label2.setText(str(x)))
                yolo_thread.send_class_num.connect(lambda x: self.ui.Class_num2.setText(str(x)))
                yolo_thread.send_target_num.connect(lambda x: self.ui.Target_num2.setText(str(x)))
                self.log("[DEBUG] 右侧模型信号连接完成")
                
            self.log(f"[DEBUG] ========== initModel 完成: {yoloname} ==========")
        except Exception as e:
            self.log(f"[ERROR] initModel 出错 ({yoloname}): {e}")
            import traceback
            self.log(traceback.format_exc())
            raise


    # 在MessageBar显示消息
    def showStatus(self, msg):
        self.ui.message_bar.setText(msg)
        # 检测完成的消息可能是英文或中英文混合
        if msg == 'Finish Detection' or msg == '检测完成 (Finish Detection)' or 'Finish Detection' in msg:
            self.quitRunningModel()
            self.ui.run_button.setChecked(False)
            self.ui.progress_bar.setValue(0)
        elif msg == 'Stop Detection':
            self.quitRunningModel()
            self.ui.run_button.setChecked(False)
            self.ui.progress_bar.setValue(0)
            self.ui.Class_num1.setText('--')
            self.ui.Target_num1.setText('--')
            self.ui.fps_label1.setText('--')
            self.ui.Class_num2.setText('--')
            self.ui.Target_num2.setText('--')
            self.ui.fps_label2.setText('--')
            self.ui.main_leftbox.clear()  # clear image display
            self.ui.main_rightbox.clear()

    # 导出结果
    def saveResult(self):
        self.log("[DEBUG] ========== saveResult 开始 ==========")
        
        # 检查是否有线程正在运行且未暂停
        is_detecting = False
        for thread in self.yolo_threads.threads_pool.values():
            if thread.isRunning() and hasattr(thread, 'is_continue') and thread.is_continue:
                is_detecting = True
                break
        
        if is_detecting:
            # 对比模式只有文件/视频模式，提示等待检测完成
            self.showStatus("检测正在进行中，请等待检测完成 (Detection in progress, please wait)")
            self.log("[WARNING] 检测正在进行中，无法保存")
            return
        
        # 检查是否有检测结果
        left_thread = None
        right_thread = None
        for thread_name, thread in self.yolo_threads.threads_pool.items():
            if thread_name.endswith("left"):
                left_thread = thread
            elif thread_name.endswith("right"):
                right_thread = thread
        
        # 检查是否至少有一个线程运行过检测
        has_left_results = False
        has_right_results = False
        
        if left_thread:
            has_left_results = (hasattr(left_thread, 'seen') and left_thread.seen > 0) or \
                              (hasattr(left_thread, 'res_status') and left_thread.res_status)
        
        if right_thread:
            has_right_results = (hasattr(right_thread, 'seen') and right_thread.seen > 0) or \
                               (hasattr(right_thread, 'res_status') and right_thread.res_status)
        
        self.log(f"[DEBUG] 左侧结果: {has_left_results}, 右侧结果: {has_right_results}")
        
        if not has_left_results and not has_right_results:
            self.showStatus("请先运行检测再保存结果 (Please run detection before saving results)")
            return
        
        # 检查是否有实际的检测结果文件
        has_left_res_path = has_left_results and hasattr(left_thread, 'res_path') and left_thread.res_path
        has_right_res_path = has_right_results and hasattr(right_thread, 'res_path') and right_thread.res_path
        
        if not has_left_res_path and not has_right_res_path:
            self.showStatus("无检测结果，无法保存 (No detection results to save)")
            self.log("[WARNING] 无检测结果文件")
            return
        
        config_file = f'{self.current_workpath}/config/save.json'
        with open(config_file, 'r', encoding='utf-8') as f:
            config = json.load(f)

        save_path = config.get('save_path', os.getcwd())
        is_folder = isinstance(self.inputPath, list)
        
        self.log(f"[DEBUG] 是否为文件夹模式: {is_folder}")
        
        if is_folder:
            # 文件夹模式：默认合并保存，选择文件夹
            self.OutputDir = QFileDialog.getExistingDirectory(
                self,
                "选择保存结果的文件夹 (Select Folder to Save Results)",
                save_path,
            )
            if not self.OutputDir:
                self.log("[DEBUG] 用户取消保存")
                return
            
            self.log(f"[DEBUG] 保存目录: {self.OutputDir}")
            
            # 文件夹模式：合并保存左右两个模型的检测结果
            if has_left_results and has_right_results:
                self.log("[DEBUG] 合并保存左右模型结果")
                # 这里需要实现文件夹模式的合并保存逻辑
                # 暂时保存到不同子文件夹
                left_model_name = self.checkCurrentModel(mode="left")
                right_model_name = self.checkCurrentModel(mode="right")
                
                left_output_dir = os.path.join(self.OutputDir, "left_model")
                right_output_dir = os.path.join(self.OutputDir, "right_model")
                os.makedirs(left_output_dir, exist_ok=True)
                os.makedirs(right_output_dir, exist_ok=True)
                
                if hasattr(left_thread, 'res_path') and left_thread.res_path:
                    self.saveResultProcess(left_output_dir, left_model_name, folder=True)
                    self.log(f"[DEBUG] 左侧模型结果已保存到: {left_output_dir}")
                
                if hasattr(right_thread, 'res_path') and right_thread.res_path:
                    self.saveResultProcess(right_output_dir, right_model_name, folder=True)
                    self.log(f"[DEBUG] 右侧模型结果已保存到: {right_output_dir}")
                
                self.showStatus(f'保存成功，位置：{self.OutputDir} (Saved Successfully)')
            elif has_left_results:
                left_model_name = self.checkCurrentModel(mode="left")
                if hasattr(left_thread, 'res_path') and left_thread.res_path:
                    self.saveResultProcess(self.OutputDir, left_model_name, folder=True)
                    self.showStatus(f'左侧模型保存成功 (Left model saved successfully)')
            elif has_right_results:
                right_model_name = self.checkCurrentModel(mode="right")
                if hasattr(right_thread, 'res_path') and right_thread.res_path:
                    self.saveResultProcess(self.OutputDir, right_model_name, folder=True)
                    self.showStatus(f'右侧模型保存成功 (Right model saved successfully)')
        else:
            # 单文件/视频模式：询问用户保存方式（合并或分开）
            if has_left_results and has_right_results:
                from PySide6.QtWidgets import QMessageBox
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("选择保存方式 (Choose Save Mode)")
                msg_box.setText("检测到两个模型都有结果，请选择保存方式：\n(Both models have results, please choose save mode:)")
                msg_box.setInformativeText(
                    "• 合并保存：将两个模型的结果左右并排保存到一个视频中\n"
                    "  (Merge: Save both results side-by-side in one video)\n\n"
                    "• 分别保存：分别保存两个模型的结果到不同文件\n"
                    "  (Separate: Save each model's result to different files)"
                )
                merge_button = msg_box.addButton("合并保存 (Merge)", QMessageBox.AcceptRole)
                separate_button = msg_box.addButton("分别保存 (Separate)", QMessageBox.RejectRole)
                cancel_button = msg_box.addButton("取消 (Cancel)", QMessageBox.RejectRole)
                msg_box.setDefaultButton(merge_button)
                msg_box.exec()
                
                if msg_box.clickedButton() == cancel_button:
                    self.log("[DEBUG] 用户取消保存")
                    return
                elif msg_box.clickedButton() == merge_button:
                    # 合并保存模式
                    self.log("[DEBUG] 用户选择合并保存")
                    self.saveMergedResult(left_thread, right_thread, save_path, config_file, config)
                    return
                else:
                    # 分别保存模式
                    self.log("[DEBUG] 用户选择分别保存")
                    self.saveSeparateResults(left_thread, right_thread, save_path, config_file, config)
                    return
            elif has_left_results:
                # 只有左侧结果
                self.log("[DEBUG] 只有左侧模型有结果")
                self.saveSingleModelResult(left_thread, "left", save_path, config_file, config)
            elif has_right_results:
                # 只有右侧结果
                self.log("[DEBUG] 只有右侧模型有结果")
                self.saveSingleModelResult(right_thread, "right", save_path, config_file, config)
        
        config['save_path'] = os.path.dirname(self.OutputDir) if self.OutputDir else save_path
        config_json = json.dumps(config, ensure_ascii=False, indent=2)
        with open(config_file, 'w', encoding='utf-8') as f:
            f.write(config_json)
        
        self.log("[DEBUG] ========== saveResult 完成 ==========")
    
    def saveSingleModelResult(self, thread, side, save_path, config_file, config):
        """保存单个模型的结果"""
        from pathlib import Path
        
        input_path = self.inputPath if isinstance(self.inputPath, str) else self.inputPath[0]
        input_ext = Path(input_path).suffix.lower()
        
        # 根据输入文件类型确定输出扩展名和过滤器
        if input_ext in ['.jpg', '.jpeg', '.png', '.bmp', '.dib', '.jpe', '.jp2']:
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有图片 (*.jpg *.jpeg *.png *.bmp)"
        elif input_ext in ['.mp4', '.avi', '.mov', '.mkv', '.flv', '.wmv']:
            import platform
            if platform.system() == 'Darwin':
                default_ext = '.mp4'
                file_filter = "MP4 视频 (*.mp4);;所有视频 (*.mp4 *.avi)"
            else:
                default_ext = '.avi'
                file_filter = "AVI 视频 (*.avi);;MP4 视频 (*.mp4);;所有视频 (*.avi *.mp4)"
        else:
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有文件 (*.*)"
        
        input_basename = Path(input_path).stem
        side_text = "左侧" if side == "left" else "右侧"
        side_en = "Left" if side == "left" else "Right"
        
        default_filename = f"{input_basename}_{side}_result{default_ext}"
        default_save_path = os.path.join(save_path, default_filename)
        
        output_path, selected_filter = QFileDialog.getSaveFileName(
            self,
            f"保存{side_text}模型检测结果 (Save {side_en} Model Result)",
            default_save_path,
            file_filter
        )
        
        if output_path:
            model_name = self.checkCurrentModel(mode=side)
            self.saveResultProcess(output_path, model_name, folder=False)
            self.showStatus(f'{side_text}模型保存成功 ({side_en} model saved successfully)')
            self.OutputDir = output_path
    
    def saveSeparateResults(self, left_thread, right_thread, save_path, config_file, config):
        """分别保存左右两个模型的结果"""
        from pathlib import Path
        
        input_path = self.inputPath if isinstance(self.inputPath, str) else self.inputPath[0]
        input_ext = Path(input_path).suffix.lower()
        
        # 根据输入文件类型确定输出扩展名和过滤器
        if input_ext in ['.jpg', '.jpeg', '.png', '.bmp', '.dib', '.jpe', '.jp2']:
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有图片 (*.jpg *.jpeg *.png *.bmp)"
        elif input_ext in ['.mp4', '.avi', '.mov', '.mkv', '.flv', '.wmv']:
            import platform
            if platform.system() == 'Darwin':
                default_ext = '.mp4'
                file_filter = "MP4 视频 (*.mp4);;所有视频 (*.mp4 *.avi)"
            else:
                default_ext = '.avi'
                file_filter = "AVI 视频 (*.avi);;MP4 视频 (*.mp4);;所有视频 (*.avi *.mp4)"
        else:
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有文件 (*.*)"
        
        input_basename = Path(input_path).stem
        self.OutputDir = None
        
        # 保存左侧模型结果
        if hasattr(left_thread, 'res_path') and left_thread.res_path:
            default_filename = f"{input_basename}_left_result{default_ext}"
            default_save_path = os.path.join(save_path, default_filename)
            
            left_output_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "保存左侧模型检测结果 (Save Left Model Result)",
                default_save_path,
                file_filter
            )
            if left_output_path:
                left_model_name = self.checkCurrentModel(mode="left")
                self.saveResultProcess(left_output_path, left_model_name, folder=False)
                self.showStatus(f'左侧模型保存成功 (Left model saved successfully)')
                self.OutputDir = left_output_path
        
        # 保存右侧模型结果
        if hasattr(right_thread, 'res_path') and right_thread.res_path:
            default_filename = f"{input_basename}_right_result{default_ext}"
            default_save_path = os.path.join(save_path, default_filename)
            
            right_output_path, selected_filter = QFileDialog.getSaveFileName(
                self,
                "保存右侧模型检测结果 (Save Right Model Result)",
                default_save_path,
                file_filter
            )
            if right_output_path:
                right_model_name = self.checkCurrentModel(mode="right")
                self.saveResultProcess(right_output_path, right_model_name, folder=False)
                self.showStatus(f'右侧模型保存成功 (Right model saved successfully)')
                if not self.OutputDir:
                    self.OutputDir = right_output_path

    # 合并保存两个模型的结果（左右并排）
    def saveMergedResult(self, left_thread, right_thread, save_path, config_file, config):
        """将左右两个模型的检测结果合并成一个左右并排的视频"""
        from pathlib import Path
        import platform
        
        # 获取原始文件信息
        input_path = self.inputPath if isinstance(self.inputPath, str) else self.inputPath[0]
        input_ext = Path(input_path).suffix.lower()
        
        # 根据输入文件类型确定输出扩展名和过滤器
        if input_ext in ['.jpg', '.jpeg', '.png', '.bmp', '.dib', '.jpe', '.jp2']:
            # 图片文件
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有图片 (*.jpg *.jpeg *.png *.bmp)"
        elif input_ext in ['.mp4', '.avi', '.mov', '.mkv', '.flv', '.wmv']:
            # 视频文件
            if platform.system() == 'Darwin':  # macOS
                default_ext = '.mp4'
                file_filter = "MP4 视频 (*.mp4);;所有视频 (*.mp4 *.avi)"
            else:  # Windows/Linux
                default_ext = '.avi'
                file_filter = "AVI 视频 (*.avi);;MP4 视频 (*.mp4);;所有视频 (*.avi *.mp4)"
        else:
            default_ext = '.jpg'
            file_filter = "JPEG 图片 (*.jpg);;PNG 图片 (*.png);;所有文件 (*.*)"
        
        # 生成默认文件名：原文件名_comparison + 扩展名
        input_basename = Path(input_path).stem
        default_filename = f"{input_basename}_comparison{default_ext}"
        default_save_path = os.path.join(save_path, default_filename)
        
        # 弹出保存对话框
        output_path, selected_filter = QFileDialog.getSaveFileName(
            self,
            "保存对比结果 (Save Comparison Result)",
            default_save_path,
            file_filter
        )
        
        if not output_path:
            return
        
        # 检查是否有保存的结果文件
        left_res_path = left_thread.res_path if hasattr(left_thread, 'res_path') else None
        right_res_path = right_thread.res_path if hasattr(right_thread, 'res_path') else None
        
        if not left_res_path or not right_res_path:
            self.showStatus("检测结果文件未找到，请重新运行检测 (Result files not found, please re-run detection)")
            return
        
        if not os.path.exists(left_res_path) or not os.path.exists(right_res_path):
            self.showStatus("检测结果文件不存在，请重新运行检测 (Result files do not exist, please re-run detection)")
            return
        
        try:
            self.showStatus("正在合并视频... (Merging videos...)")
            
            if input_ext in ['.jpg', '.jpeg', '.png', '.bmp', '.dib', '.jpe', '.jp2']:
                # 图片：左右拼接（支持中文路径）
                # 使用 np.fromfile 和 cv2.imdecode 读取中文路径
                left_img = cv2.imdecode(np.fromfile(left_res_path, dtype=np.uint8), cv2.IMREAD_COLOR)
                right_img = cv2.imdecode(np.fromfile(right_res_path, dtype=np.uint8), cv2.IMREAD_COLOR)
                
                if left_img is None or right_img is None:
                    self.showStatus("无法读取检测结果图片 (Cannot read result images)")
                    return
                
                # 调整两张图片到相同高度
                h1, w1 = left_img.shape[:2]
                h2, w2 = right_img.shape[:2]
                target_height = max(h1, h2)
                
                if h1 != target_height:
                    left_img = cv2.resize(left_img, (int(w1 * target_height / h1), target_height))
                if h2 != target_height:
                    right_img = cv2.resize(right_img, (int(w2 * target_height / h2), target_height))
                
                # 左右拼接
                merged_img = np.hstack([left_img, right_img])
                
                # 保存图片（支持中文路径）
                success, encoded_img = cv2.imencode(Path(output_path).suffix, merged_img)
                if success:
                    with open(output_path, 'wb') as f:
                        f.write(encoded_img.tobytes())
                    self.showStatus(f'保存成功：{output_path} (Saved Successfully)')
                else:
                    self.showStatus("图片编码失败 (Image encoding failed)")
                    
            else:
                # 视频：逐帧读取并左右拼接
                # 注意：cv2.VideoCapture 和 cv2.VideoWriter 不支持中文路径
                # 如果输出路径包含中文，使用临时文件
                import tempfile
                import shutil
                
                # 检查输出路径是否包含中文
                has_chinese = any('\u4e00' <= char <= '\u9fff' for char in output_path)
                
                if has_chinese:
                    # 创建临时文件
                    temp_dir = tempfile.gettempdir()
                    temp_filename = f"temp_merged_{int(time.time())}{Path(output_path).suffix}"
                    temp_output_path = os.path.join(temp_dir, temp_filename)
                else:
                    temp_output_path = output_path
                
                left_cap = cv2.VideoCapture(left_res_path)
                right_cap = cv2.VideoCapture(right_res_path)
                
                if not left_cap.isOpened() or not right_cap.isOpened():
                    self.showStatus("无法打开检测结果视频 (Cannot open result videos)")
                    left_cap.release()
                    right_cap.release()
                    return
                
                # 获取视频属性
                fps = int(left_cap.get(cv2.CAP_PROP_FPS))
                frame_count = int(min(left_cap.get(cv2.CAP_PROP_FRAME_COUNT), 
                                     right_cap.get(cv2.CAP_PROP_FRAME_COUNT)))
                
                # 读取第一帧以确定尺寸
                ret1, frame1 = left_cap.read()
                ret2, frame2 = right_cap.read()
                
                if not ret1 or not ret2:
                    self.showStatus("无法读取视频帧 (Cannot read video frames)")
                    left_cap.release()
                    right_cap.release()
                    return
                
                # 调整两个视频到相同高度
                h1, w1 = frame1.shape[:2]
                h2, w2 = frame2.shape[:2]
                target_height = max(h1, h2)
                
                # 计算合并后的宽度
                new_w1 = int(w1 * target_height / h1) if h1 != target_height else w1
                new_w2 = int(w2 * target_height / h2) if h2 != target_height else w2
                merged_width = new_w1 + new_w2
                
                # 创建视频写入器
                suffix = Path(output_path).suffix
                if suffix == '.mp4':
                    fourcc = cv2.VideoWriter_fourcc(*'avc1') if platform.system() == 'Darwin' else cv2.VideoWriter_fourcc(*'mp4v')
                else:  # .avi
                    fourcc = cv2.VideoWriter_fourcc(*'WMV2') if platform.system() == 'Windows' else cv2.VideoWriter_fourcc(*'MJPG')
                
                out = cv2.VideoWriter(temp_output_path, fourcc, fps, (merged_width, target_height))
                
                if not out.isOpened():
                    self.showStatus("无法创建输出视频 (Cannot create output video)")
                    left_cap.release()
                    right_cap.release()
                    return
                
                # 重置到开始
                left_cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                right_cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                
                # 逐帧处理
                frame_idx = 0
                while True:
                    ret1, frame1 = left_cap.read()
                    ret2, frame2 = right_cap.read()
                    
                    if not ret1 or not ret2:
                        break
                    
                    # 调整尺寸
                    if frame1.shape[0] != target_height:
                        frame1 = cv2.resize(frame1, (new_w1, target_height))
                    if frame2.shape[0] != target_height:
                        frame2 = cv2.resize(frame2, (new_w2, target_height))
                    
                    # 左右拼接
                    merged_frame = np.hstack([frame1, frame2])
                    
                    # 写入
                    out.write(merged_frame)
                    
                    frame_idx += 1
                    if frame_idx % 30 == 0:  # 每30帧更新一次进度
                        progress = int(frame_idx / frame_count * 100)
                        self.showStatus(f'正在合并视频... {progress}% (Merging videos... {progress}%)')
                
                # 释放资源
                left_cap.release()
                right_cap.release()
                out.release()
                
                # 如果使用了临时文件，移动到目标位置
                if has_chinese:
                    try:
                        shutil.move(temp_output_path, output_path)
                        self.showStatus(f'保存成功：{output_path} (Saved Successfully)')
                    except Exception as e:
                        self.showStatus(f'移动文件失败：{str(e)} (Failed to move file)')
                        # 尝试删除临时文件
                        try:
                            os.remove(temp_output_path)
                        except:
                            pass
                        return
                else:
                    self.showStatus(f'保存成功：{output_path} (Saved Successfully)')
            
            # 保存结果图和结果表到同一目录
            output_dir = os.path.dirname(output_path)
            self.saveResultStatistics(output_dir, prefix=f"{input_basename}_comparison")
                
        except Exception as e:
            self.showStatus(f'保存失败：{str(e)} (Save failed)')
            import traceback
            print(traceback.format_exc())
        
        # 更新配置
        config['save_path'] = os.path.dirname(output_path)
        config_json = json.dumps(config, ensure_ascii=False, indent=2)
        with open(config_file, 'w', encoding='utf-8') as f:
            f.write(config_json)

    def saveResultStatistics(self, output_dir, prefix=""):
        """保存结果图和结果表到指定目录
        
        Args:
            output_dir: 输出目录
            prefix: 文件名前缀（可选）
        """
        try:
            # 读取结果统计数据
            result_json_path = os.path.join(self.current_workpath, 'config', 'result.json')
            result_png_path = os.path.join(self.current_workpath, 'config', 'result.png')
            
            # 检查文件是否存在
            if not os.path.exists(result_json_path):
                print(f"[WARNING] 结果文件不存在: {result_json_path}")
                return
            
            # 读取结果数据
            with open(result_json_path, 'r', encoding='utf-8') as f:
                result_data = json.load(f)
            
            if not result_data:
                print(f"[WARNING] 结果数据为空")
                return
            
            # 生成文件名
            if prefix:
                json_filename = f"{prefix}_result.json"
                png_filename = f"{prefix}_result.png"
                txt_filename = f"{prefix}_result.txt"
            else:
                json_filename = "result.json"
                png_filename = "result.png"
                txt_filename = "result.txt"
            
            # 保存 JSON 文件
            output_json_path = os.path.join(output_dir, json_filename)
            with open(output_json_path, 'w', encoding='utf-8') as f:
                json.dump(result_data, f, ensure_ascii=False, indent=4)
            print(f"[INFO] 结果JSON已保存: {output_json_path}")
            
            # 保存 PNG 文件（如果存在）
            if os.path.exists(result_png_path):
                output_png_path = os.path.join(output_dir, png_filename)
                shutil.copy(result_png_path, output_png_path)
                print(f"[INFO] 结果图已保存: {output_png_path}")
            
            # 保存 TXT 文件（结果表格式）
            output_txt_path = os.path.join(output_dir, txt_filename)
            with open(output_txt_path, 'w', encoding='utf-8') as f:
                f.write("检测结果统计 (Detection Result Statistics)\n")
                f.write("=" * 50 + "\n\n")
                f.write(f"{'类别 (Class)':<30} {'数量 (Count)':>10}\n")
                f.write("-" * 50 + "\n")
                for class_name, count in result_data.items():
                    f.write(f"{class_name:<30} {count:>10}\n")
                f.write("-" * 50 + "\n")
                f.write(f"{'总计 (Total)':<30} {sum(result_data.values()):>10}\n")
            print(f"[INFO] 结果表已保存: {output_txt_path}")
            
        except Exception as e:
            print(f"[ERROR] 保存结果统计时出错: {e}")
            import traceback
            traceback.print_exc()

    # 加载 pt 模型到 model_box
    def loadModels(self):
        pt_list = os.listdir(f'{self.current_workpath}/ptfiles/')
        pt_list = [file for file in pt_list if file.endswith('.pt')]
        pt_list.sort(key=lambda x: os.path.getsize(f'{self.current_workpath}/ptfiles/' + x))

        if pt_list != self.pt_list:
            self.pt_list = pt_list
            self.ui.model_box1.clear()
            self.ui.model_box1.addItems(self.pt_list)
            self.ui.model_box2.clear()
            self.ui.model_box2.addItems(self.pt_list)

    # 重新加载模型
    def resignModel(self, model_name, mode=None):
        # 注释掉 reloadModel()，因为它会导致已创建的线程对象失效
        # self.reloadModel()
        self.yolo_threads.set(model_name, MODEL_THREAD_CLASSES[model_name]())
        self.initModel(yoloname=model_name)
        self.ui.run_button.setChecked(True)
        if mode == "left":
            self.ContinueAnotherModel(mode="right")
        else:
            self.ContinueAnotherModel(mode="left")
        self.runModel(True)

    def stopOtherModelProcess(self, model_name, current_yoloname, mode="left"):
        yolo_thread = self.yolo_threads.get(model_name)
        yolo_thread.finished.connect((lambda: self.resignModel(current_yoloname, mode=mode)))
        yolo_thread.stop_dtc = True
        self.yolo_threads.stop_thread(model_name)

    # 停止其他模型
    def stopOtherModel(self, current_yoloname=None, mode=None):
        for model_name, thread in self.yolo_threads.threads_pool.items():
            if not current_yoloname or model_name == current_yoloname:
                continue
            if not thread.isRunning():
                continue
            if mode == "left":
                self.PauseAnotherModel(mode="right")
                self.stopOtherModelProcess(model_name, current_yoloname, mode=mode)
            else:
                self.PauseAnotherModel(mode="left")
                self.stopOtherModelProcess(model_name, current_yoloname, mode=mode)

    def PauseAnotherModelProcess(self, model_name):
        yolo_thread = self.yolo_threads.get(model_name)
        yolo_thread.stop_dtc = True
        self.yolo_threads.stop_thread(model_name)

    # 暂停另外一侧模型
    def PauseAnotherModel(self, mode=None):
        buttonStatus = self.ui.run_button.isChecked()
        if buttonStatus:
            model_name_another = self.checkCurrentModel(mode=mode)
            self.PauseAnotherModelProcess(model_name_another)

    # 继续另外一侧模型
    def ContinueAnotherModel(self, mode=None):
        buttonStatus = self.ui.run_button.isChecked()
        if buttonStatus:
            model_name_another = self.checkCurrentModel(mode=mode)
            self.yolo_threads.set(model_name_another, MODEL_THREAD_CLASSES[model_name_another]())
            self.initModel(yoloname=model_name_another)

    def changeModelProcess(self, yoloname, mode=None):
        if mode == "left":
            self.stopOtherModel(yoloname, mode="left")
            yolo_thread = self.yolo_threads.get(yoloname)
            if yolo_thread is not None:
                yolo_thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box1.currentText()
            else:
                self.yolo_threads.set(yoloname, MODEL_THREAD_CLASSES[yoloname]())
                self.initModel(yoloname=yoloname)
                self.loadConfig()
                self.showStatus(f"Change Model to {yoloname} Successfully for Left Part")
            # 重载 common 和 yolo 模块
            glo.set_value('yoloname1', yoloname)
        else:
            self.stopOtherModel(yoloname, mode="right")
            yolo_thread = self.yolo_threads.get(yoloname)
            if yolo_thread is not None:
                yolo_thread.new_model_name = f'{self.current_workpath}/ptfiles/' + self.ui.model_box2.currentText()
            else:
                self.yolo_threads.set(yoloname, MODEL_THREAD_CLASSES[yoloname]())
                self.initModel(yoloname=yoloname)
                self.loadConfig()
                self.showStatus(f"Change Model to {yoloname} Successfully for Right Part")
            # 重载 common 和 yolo 模块
            glo.set_value('yoloname2', yoloname)

    # Model 变化
    def changeModel(self, mode=None):
        if mode == "left":
            # 左侧模型
            self.model_name1 = self.ui.model_box1.currentText()
            self.ui.Model_label1.setText(str(self.model_name1).replace(".pt", ""))  # 修改状态栏显示
            yolo_name = self.checkCurrentModel(mode="left")
            if yolo_name:
                self.changeModelProcess(yolo_name, "left")
            else:
                self.stopOtherModel(mode="left")
        else:
            # 右侧模型
            self.model_name2 = self.ui.model_box2.currentText()
            self.ui.Model_label2.setText(str(self.model_name2).replace(".pt", ""))
            yolo_name = self.checkCurrentModel(mode="right")
            if yolo_name:
                self.changeModelProcess(yolo_name, "right")
            else:
                self.stopOtherModel(mode="right")

    def runRightModelProcess(self, model_name, mode="start"):
        yolo_thread = self.yolo_threads.get(model_name)
        if mode == "start":
            yolo_thread.source = self.inputPath
            yolo_thread.stop_dtc = False
            yolo_thread.is_continue = True
            self.yolo_threads.start_thread(model_name)
        else:
            yolo_thread.is_continue = False

    # 运行右侧模型
    def runRightModel(self, mode=None):
        model_name_right = self.checkCurrentModel(mode="right")
        if mode == "start":
            self.runRightModelProcess(model_name_right, "start")
        elif mode == "pause":
            self.runRightModelProcess(model_name_right, "pause")

    def runModelProcess(self, yolo_name):
        self.log(f"[DEBUG] ========== runModelProcess 开始: {yolo_name} ==========")
        
        try:
            yolo_thread = self.yolo_threads.get(yolo_name)
            self.log(f"[DEBUG] 获取到线程: {yolo_thread}")
            
            if not yolo_thread:
                self.log(f"[ERROR] 未找到线程: {yolo_name}")
                return
            
            yolo_thread.source = self.inputPath
            self.log(f"[DEBUG] 设置输入源: {self.inputPath}")
            
            yolo_thread.stop_dtc = False
            
            if self.ui.run_button.isChecked():
                self.log("[DEBUG] 开始检测")
                yolo_thread.is_continue = True
                
                self.log(f"[DEBUG] 启动线程: {yolo_name}")
                self.yolo_threads.start_thread(yolo_name)
                self.log(f"[DEBUG] 线程已启动")
                
                self.log("[DEBUG] 启动右侧模型")
                self.runRightModel(mode="start")
                self.log("[DEBUG] 右侧模型已启动")
            else:
                self.log("[DEBUG] 暂停检测")
                yolo_thread.is_continue = False
                self.runRightModel(mode="pause")
                self.showStatus('Pause Detection')
                
            self.log(f"[DEBUG] ========== runModelProcess 完成: {yolo_name} ==========")
        except Exception as e:
            self.log(f"[ERROR] runModelProcess 出错 ({yolo_name}): {e}")
            import traceback
            self.log(traceback.format_exc())
            raise

    # 运行模型
    def runModel(self, runbuttonStatus=None):
        self.log("[DEBUG] ========== runModel 开始 ==========")
        self.log(f"[DEBUG] runbuttonStatus: {runbuttonStatus}")
        
        try:
            if runbuttonStatus:
                self.ui.run_button.setChecked(True)
            
            # 首先判断是否两边的模型均为正确模型
            self.log(f"[DEBUG] 检查模型名称: model_name1={self.model_name1}, model_name2={self.model_name2}")
            
            if self.checkModelName(self.model_name1) and self.checkModelName(self.model_name2):
                self.showStatus('The current model is not supported')
                if self.ui.run_button.isChecked():
                    self.ui.run_button.setChecked(False)
                self.log("[DEBUG] 模型不支持，退出")
                return
            
            # 左侧模型
            model_name_left = self.checkCurrentModel(mode="left")
            self.log(f"[DEBUG] 左侧模型名称: {model_name_left}")
            
            if model_name_left:
                self.log("[DEBUG] 开始运行左侧模型")
                self.runModelProcess(model_name_left)
                self.log("[DEBUG] 左侧模型运行完成")
            else:
                self.log("[DEBUG] 左侧模型名称为空")
                
            self.log("[DEBUG] ========== runModel 完成 ==========")
        except Exception as e:
            self.log(f"[ERROR] runModel 出错: {e}")
            import traceback
            self.log(traceback.format_exc())
            raise

    # 开始/暂停 预测
    def runorContinue(self):
        self.log("[DEBUG] ========== runorContinue 开始 ==========")
        self.log(f"[DEBUG] inputPath: {self.inputPath}")
        
        try:
            if self.inputPath is not None:
                self.log("[DEBUG] 设置全局变量")
                glo.set_value('yoloname1', self.model_name1)
                glo.set_value('yoloname2', self.model_name2)
                self.log(f"[DEBUG] yoloname1={self.model_name1}, yoloname2={self.model_name2}")
                
                # 清空之前的检测结果，避免结果累加
                result_json_path = os.path.join(self.current_workpath, 'config', 'result.json')
                try:
                    if os.path.exists(result_json_path):
                        with open(result_json_path, 'w', encoding='utf-8') as f:
                            json.dump({}, f, ensure_ascii=False, indent=4)
                        self.log("[DEBUG] 已清空之前的检测结果 result.json")
                except Exception as e:
                    self.log(f"[WARNING] 清空结果文件失败: {e}")
                
                # 注释掉 reloadModel()，因为它会导致已创建的线程对象失效
                # 在对比模式下，线程已经在 initThreads() 中创建，不需要重新加载模块
                # self.log("[DEBUG] 重新加载模型")
                # try:
                #     self.reloadModel()
                #     self.log("[DEBUG] 模型重新加载完成")
                # except Exception as e:
                #     self.log(f"[ERROR] reloadModel 出错: {e}")
                #     import traceback
                #     self.log(traceback.format_exc())
                #     raise
                
                self.log("[DEBUG] 调用 runModel")
                self.runModel()
                self.log("[DEBUG] runModel 完成")
            else:
                self.log("[DEBUG] inputPath 为空，显示提示")
                self.showStatus("请先选择图片/视频再开始检测 (Please select the Image/Video before starting detection)")
                self.ui.run_button.setChecked(False)
                
            self.log("[DEBUG] ========== runorContinue 完成 ==========")
        except Exception as e:
            self.log(f"[ERROR] runorContinue 出错: {e}")
            import traceback
            self.log(traceback.format_exc())
            # 不要 raise，避免崩溃
            self.showStatus(f"检测启动失败: {e}")
            self.ui.run_button.setChecked(False)

    # 停止识别
    def stopDetect(self):
        self.quitRunningModel(stop_status=True)
        self.ui.run_button.setChecked(False)
        self.ui.progress_bar.setValue(0)
        self.ui.main_leftbox.clear()  # clear image display
        self.ui.main_rightbox.clear()
        self.ui.Class_num1.setText('--')
        self.ui.Target_num1.setText('--')
        self.ui.fps_label1.setText('--')
        self.ui.Class_num2.setText('--')
        self.ui.Target_num2.setText('--')
        self.ui.fps_label2.setText('--')

    # 添加中文标签到界面元素
    def addChineseLabels(self):
        """为VS模式界面添加中文标签和工具提示"""
        # 左侧菜单按钮 - 添加中文文本（使用换行符避免被截断）
        self.ui.src_img.setText("Media\n媒体")
        self.ui.src_folder.setText("Folder\n文件夹")
        self.ui.src_singlemode.setText("SG Mode\n单模式")
        self.ui.src_menu.setText("Menu\n菜单")
        self.ui.src_setting.setText("Setting\n设置")
        
        # 状态栏标签 - 使用简洁的中文标注（避免换行导致遮挡）
        self.ui.label_5.setText("类别")
        self.ui.label_6.setText("目标")
        self.ui.label_7.setText("帧率")
        self.ui.label_8.setText("模型")
        self.ui.label_12.setText("类别")
        self.ui.label_9.setText("目标")
        self.ui.label_10.setText("帧率")
        self.ui.label_11.setText("模型")
        
        # 状态栏工具提示（鼠标悬停显示完整说明）
        self.ui.label_5.setToolTip("Classes 类别\n左侧模型检测到的类别数量\nLeft model detected classes")
        self.ui.label_6.setToolTip("Targets 目标\n左侧模型检测到的目标数量\nLeft model detected targets")
        self.ui.label_7.setToolTip("Fps 帧率\n左侧模型每秒处理帧数\nLeft model FPS")
        self.ui.label_8.setToolTip("Model 模型\n左侧当前使用的模型\nLeft current model")
        self.ui.label_12.setToolTip("Classes 类别\n右侧模型检测到的类别数量\nRight model detected classes")
        self.ui.label_9.setToolTip("Targets 目标\n右侧模型检测到的目标数量\nRight model detected targets")
        self.ui.label_10.setToolTip("Fps 帧率\n右侧模型每秒处理帧数\nRight model FPS")
        self.ui.label_11.setToolTip("Model 模型\n右侧当前使用的模型\nRight current model")
        
        # 右侧设置面板 - 添加中文标签
        self.ui.ToggleBotton_6.setText("Left Model 左侧模型")
        self.ui.ToggleBotton_7.setText("Right Model 右侧模型")
        self.ui.ToggleBotton_2.setText("IOU 交并比")
        self.ui.ToggleBotton_3.setText("Confidence 置信度")
        self.ui.ToggleBotton_4.setText("Delay(ms) 延迟")
        self.ui.ToggleBotton_5.setText("Line Width 线宽")
        
        # 按钮 - 添加中文标签
        self.ui.save_button.setText("Save Result 保存结果")
        
        # 添加工具提示（鼠标悬停时显示详细信息）
        self.ui.src_img.setToolTip("选择图片或视频文件进行检测\nSelect image or video file for detection")
        self.ui.src_folder.setToolTip("选择文件夹进行批量检测\nSelect folder for batch detection")
        self.ui.src_singlemode.setToolTip("切换到单模型模式\nSwitch to single model mode")
        
        self.ui.model_box1.setToolTip("选择左侧检测模型\nSelect left detection model")
        self.ui.model_box2.setToolTip("选择右侧检测模型\nSelect right detection model")
        
        self.ui.iou_spinbox.setToolTip("IOU阈值：用于过滤重叠的检测框\nIOU threshold: Filter overlapping detection boxes")
        self.ui.conf_spinbox.setToolTip("置信度阈值：过滤低置信度的检测结果\nConfidence threshold: Filter low-confidence detections")
        self.ui.speed_spinbox.setToolTip("检测延迟（毫秒）：控制检测速度\nDetection delay (ms): Control detection speed")
        self.ui.line_spinbox.setToolTip("检测框线宽：调整边界框的线条粗细\nBounding box line width: Adjust thickness of detection boxes")
        
        self.ui.save_button.setToolTip("保存检测结果到文件（自动保存模式已启用）\nSave detection results to file (Auto-save mode enabled)")
        
        print("[DEBUG] 中文标签已添加到VS模式界面 / Chinese labels added to VS Mode interface")
